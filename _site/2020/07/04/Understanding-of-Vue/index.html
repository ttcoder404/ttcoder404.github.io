

<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!-- Favicon Icon -->
    <link rel="shortcut icon" type="image/x-icon" href="/assets/images/favicon.png">

    <title>聊聊对Vue.js框架的理解 &mdash; 头秃程序猿 — 前端知识学习分享</title>
    <meta name="description"
          content="今年OKR定了一条KR是每一个季度进行一次前端相关技术的分享，还有十几天就到2020年了，一直忙于业务开发，没有时间准备和学习高端话题，迫于无奈，那就讲讲平时使用频率较高，却没有真正认真的了解其内部原理的 Vue.js 吧。">

    <link rel="canonical" href="http://localhost:4000/2020/07/04/Understanding-of-Vue/">
    <link rel="alternate" type="application/rss+xml" title="头秃程序猿 — 前端知识学习分享" href="http://localhost:4000/feed.xml">

    <!-- Third-Party CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/assets/vendor/primer-css/css/primer.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/assets/vendor/primer-markdown/dist/user-content.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/bower_components/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/bower_components/octicons/octicons/octicons.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/bower_components/hover/css/hover-min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/bower_components/primer-markdown/dist/user-content.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/assets/css/syntax.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/assets/css/posts/index.css">

    <!-- My CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/assets/css/common.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/assets/css/responsive.css">

    <!-- CSS set in page -->
    

    <!-- CSS set in layout -->
    

    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/bower_components/jquery/dist/jquery.min.js"></script>

    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/bower_components/bootstrap/dist/js/bootstrap.min.js"></script>

    
</head>


    <body>
    <header class="site-header">
    <div class="container">
        <a id="site-header-brand" href="/" title="ttcoder">
            <span class="octicon octicon-mark-github"></span> ttcoder
        </a>
        <nav class="site-header-nav" role="navigation">
            
            <a href="/"
               class=" site-header-nav-item hvr-underline-from-center"
               target=""
               title="Home">
                Home
            </a>
            
            <a href="/open-source"
               class=" site-header-nav-item hvr-underline-from-center"
               target=""
               title="Open-Source">
                Open-Source
            </a>
            
            <a href="/talk"
               class=" site-header-nav-item hvr-underline-from-center"
               target=""
               title="Talk">
                Talk
            </a>
            
            <a href="/archives"
               class=" site-header-nav-item hvr-underline-from-center"
               target=""
               title="Archive">
                Archive
            </a>
            
            <a href="/about"
               class=" site-header-nav-item hvr-underline-from-center"
               target=""
               title="About">
                About
            </a>
            
        </nav>
            
        <span class="nav_menu">
            <svg class="Zi Zi--More" fill="currentColor" viewBox="0 0 24 24" width="36" height="36"><path d="M3.5 5h16a1.5 1.5 0 0 1 0 3h-16a1.5 1.5 0 0 1 0-3zm0 6h16a1.5 1.5 0 0 1 0 3h-16a1.5 1.5 0 0 1 0-3zm0 6h16a1.5 1.5 0 0 1 0 3h-16a1.5 1.5 0 0 1 0-3z" fill-rule="evenodd"></path></svg>
        </span>
    </div>
    <div id="nav">        
		<div class="navigation-up">
			<ul class="nav-site">            
            
			<li _t_nav="Home" class=" ">
                <a href="/" target=""><span>Home</span></a>
            </li>               
            
			<li _t_nav="Open-Source" class=" ">
                <a href="/open-source" target=""><span>Open-Source</span></a>
            </li>               
            
			<li _t_nav="Talk" class=" ">
                <a href="/talk" target=""><span>Talk</span></a>
            </li>               
            
			<li _t_nav="Archive" class=" ">
                <a href="/archives" target=""><span>Archive</span></a>
            </li>               
            
			<li _t_nav="About" class=" ">
                <a href="/about" target=""><span>About</span></a>
            </li>               
            
			</ul>
        </div>
        
		<div class="overlay"></div>
    </div>
</header>

    
        <div class="content">
            


<section class="jumbotron geopattern" data-pattern-id="聊聊对Vue.js框架的理解">
    <div class="container">
        <div id="jumbotron-meta-info">
            <h1>聊聊对Vue.js框架的理解</h1>
            <div class="collection-info">
                
                
                <span class="meta-info">
                <span class="octicon octicon-calendar"></span> 2020/07/04
                </span>
                
                
                <span class="meta-info">
                <span class="octicon octicon-file-directory"></span>
                <a href="http://localhost:4000/talk/#Vue" title="Vue">Vue</a>
                </span>
                
                <span class="meta-info">
                <span class="octicon octicon-file-directory"></span>
                <a href="http://localhost:4000/talk/#Principle" title="Principle">Principle</a>
                </span>
                
                
                <span class="meta-info">
                <span class="octicon octicon-clock"></span>
                共 12493 字，约 36 分钟
                </span>
                
            </div>
        </div>
    </div>
</section>
<script>
    $(document).ready(function(){

        $('.geopattern').each(function(){
            $(this).geopattern($(this).data('pattern-id'));
        });

    });
</script>

<!-- / .banner -->
<section class="container content" itemscope itemtype="http://schema.org/BlogPosting">
<div class="columns">
  <div class="column three-fourths" >
    <article class="article-content markdown-body">
    <h2 id="前言">前言</h2>

<p>今年OKR定了一条KR是每一个季度进行一次前端相关技术的分享，还有十几天就到2020年了，一直忙于业务开发，没有时间准备和学习高端话题，迫于无奈，那就讲讲平时使用频率较高，却没有真正认真的了解其内部原理的 Vue.js 吧。</p>

<p>分享目标：</p>

<ul>
  <li>了解 Vue.js 的组件化机制</li>
  <li>了解 Vue.js 的响应式系统原理</li>
  <li>了解 Vue.js 中的 Virtual DOM 及 Diff 原理</li>
</ul>

<h2 id="vuejs概述">Vue.js概述</h2>

<p>Vue 是一套用于构建用户界面的渐进式MVVM框架。那怎么理解<code class="language-plaintext highlighter-rouge">渐进式</code>呢？渐进式含义：强制主张最少。</p>

<p><img src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/images/posts/interview/1-1.png" alt="渐进式概念" /></p>

<p>Vue.js包含了声明式渲染、组件化系统、客户端路由、大规模状态管理、构建工具、数据持久化、跨平台支持等，但在实际开发中，并没有强制要求开发者之后某一特定功能，而是根据需求逐渐扩展。</p>

<p>Vue.js的核心库只关心视图渲染，且由于渐进式的特性，Vue.js便于与第三方库或既有项目整合。</p>

<h2 id="组件机制">组件机制</h2>

<p>定义：组件就是对一个功能和样式进行独立的封装，让HTML元素得到扩展，从而使得代码得到复用，使得开发灵活，更加高效。</p>

<p>与HTML元素一样，Vue.js的组件拥有外部传入的属性（prop）和事件，除此之外，组件还拥有自己的状态（data）和通过数据和状态计算出来的计算属性（computed），各个维度组合起来决定组件最终呈现的样子与交互的逻辑。</p>

<h3 id="数据传递">数据传递</h3>

<p>每一个组件之间的作用域是孤立的，这个意味着组件之间的数据不应该出现引用关系，即使出现了引用关系，也不允许组件操作组件内部以外的其他数据。Vue中，允许向组件内部传递<code class="language-plaintext highlighter-rouge">prop</code>数据，组件内部需要显性地声明该<code class="language-plaintext highlighter-rouge">prop</code>字段，如下声明一个child组件：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- child.vue --&gt;</span>
<span class="nt">&lt;template&gt;</span>
    <span class="nt">&lt;div&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/template&gt;</span>
<span class="nt">&lt;script&gt;</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
    <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">msg</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">type</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
            <span class="na">default</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello world</span><span class="dl">'</span> <span class="c1">// 当default为引用类型时，需要使用 function 形式返回</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>父组件向该组件传递数据：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- parent.vue --&gt;</span>
<span class="nt">&lt;template&gt;</span>
    <span class="nt">&lt;child</span> <span class="na">:msg=</span><span class="s">"parentMsg"</span><span class="nt">&gt;&lt;/child&gt;</span>
<span class="nt">&lt;/template&gt;</span>
<span class="nt">&lt;script&gt;</span>
<span class="k">import</span> <span class="nx">child</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./child</span><span class="dl">'</span><span class="p">;</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
    <span class="na">components</span><span class="p">:</span> <span class="p">{</span>
        <span class="nx">child</span>
    <span class="p">},</span>
    <span class="nx">data</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="na">parentMsg</span><span class="p">:</span> <span class="dl">'</span><span class="s1">some words</span><span class="dl">'</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<h3 id="事件传递">事件传递</h3>

<p>Vue内部实现了一个事件总线系统，即<code class="language-plaintext highlighter-rouge">EventBus</code>。在Vue中可以使用 EventBus 来作为沟通桥梁的概念，每一个Vue的组件实例都继承了 <code class="language-plaintext highlighter-rouge">EventBus</code>，都可以接受事件<code class="language-plaintext highlighter-rouge">$on</code>和发送事件<code class="language-plaintext highlighter-rouge">$emit</code>。</p>

<p>如上面一个例子，child.vue 组件想修改 parent.vue 组件的 parentMsg 数据，怎么办呢？为了保证数据流的可追溯性，直接修改组件内 prop 的 msg 字段是不提倡的，且例子中为非引用类型 String，直接修改也修改不了，这个时候需要将修改 parentMsg 的事件传递给 child.vue，让 child.vue 来触发修改 parentMsg 的事件。如：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- child.vue --&gt;</span>
<span class="nt">&lt;template&gt;</span>
    <span class="nt">&lt;div&gt;&lt;/div&gt;</span>
<span class="nt">&lt;/template&gt;</span>
<span class="nt">&lt;script&gt;</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
    <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">msg</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">type</span><span class="p">:</span> <span class="nb">String</span><span class="p">,</span>
            <span class="na">default</span><span class="p">:</span> <span class="dl">'</span><span class="s1">hello world</span><span class="dl">'</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="na">methods</span><span class="p">:</span> <span class="p">{</span>
        <span class="nx">changeMsg</span><span class="p">(</span><span class="nx">newMsg</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">updateMsg</span><span class="dl">'</span><span class="p">,</span> <span class="nx">newMsg</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>父组件：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">&lt;!-- parent.vue --&gt;</span>
<span class="nt">&lt;template&gt;</span>
    <span class="nt">&lt;child</span> <span class="na">:msg=</span><span class="s">"parentMsg"</span> <span class="err">@</span><span class="na">updateMsg=</span><span class="s">"changeParentMsg"</span><span class="nt">&gt;&lt;/child&gt;</span>
<span class="nt">&lt;/template&gt;</span>
<span class="nt">&lt;script&gt;</span>
<span class="k">import</span> <span class="nx">child</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">./child</span><span class="dl">'</span><span class="p">;</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
    <span class="na">components</span><span class="p">:</span> <span class="p">{</span>
        <span class="nx">child</span>
    <span class="p">},</span>
    <span class="nx">data</span> <span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="na">parentMsg</span><span class="p">:</span> <span class="dl">'</span><span class="s1">some words</span><span class="dl">'</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="na">methods</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">changeParentMsg</span><span class="p">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">newMsg</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">parentMsg</span> <span class="o">=</span> <span class="nx">newMsg</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>父组件 parent.vue 向子组件 child.vue 传递了 updateMsg 事件，在子组件实例化的时候，子组件将 updateMsg 事件使用<code class="language-plaintext highlighter-rouge">$on</code>函数注册到组件内部，需要触发事件的时候，调用函数<code class="language-plaintext highlighter-rouge">this.$emit</code>来触发事件。</p>

<p>除了父子组件之间的事件传递，还可以使用一个 Vue 实例为多层级的父子组件建立数据通信的桥梁，如：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">eventBus</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Vue</span><span class="p">();</span>

<span class="c1">// 父组件中使用$on监听事件</span>
<span class="nx">eventBus</span><span class="p">.</span><span class="nx">$on</span><span class="p">(</span><span class="dl">'</span><span class="s1">eventName</span><span class="dl">'</span><span class="p">,</span> <span class="nx">val</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">//  ...do something</span>
<span class="p">})</span>

<span class="c1">// 子组件使用$emit触发事件</span>
<span class="nx">eventBus</span><span class="p">.</span><span class="nx">$emit</span><span class="p">(</span><span class="dl">'</span><span class="s1">eventName</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">this is a message.</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>除了<code class="language-plaintext highlighter-rouge">$on</code>和<code class="language-plaintext highlighter-rouge">$emit</code>以外，事件总线系统还提供了另外两个方法，<code class="language-plaintext highlighter-rouge">$once</code>和<code class="language-plaintext highlighter-rouge">$off</code>，所有事件如下：</p>

<ul>
  <li>$on：监听、注册事件。</li>
  <li>$emit：触发事件。</li>
  <li>$once：注册事件，仅允许该事件触发一次，触发结束后立即移除事件。</li>
  <li>$off：移除事件。</li>
</ul>

<h3 id="内容分发">内容分发</h3>

<p>Vue实现了一套遵循 <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md"><code class="language-plaintext highlighter-rouge">Web Components 规范草案</code></a> 的内容分发系统，即将<code class="language-plaintext highlighter-rouge">&lt;slot&gt;</code>元素作为承载分发内容的出口。</p>

<p>插槽slot，也是组件的一块HTML模板，这一块模板显示不显示、以及怎样显示由父组件来决定。实际上，一个slot最核心的两个问题在这里就点出来了，是显示不显示和怎样显示。</p>

<p>插槽又分默认插槽、具名插槽。</p>

<h4 id="默认插槽">默认插槽</h4>

<p>又名单个插槽、匿名插槽，与具名插槽相对，这类插槽没有具体名字，一个组件只能有一个该类插槽。</p>

<p>如：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;template&gt;</span>
<span class="c">&lt;!-- 父组件 parent.vue --&gt;</span>
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"parent"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;h1&gt;</span>父容器<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;child&gt;</span>
        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"tmpl"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;span&gt;</span>菜单1<span class="nt">&lt;/span&gt;</span>
        <span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;/child&gt;</span>
<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/template&gt;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;template&gt;</span>
<span class="c">&lt;!-- 子组件 child.vue --&gt;</span>
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"child"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;h1&gt;</span>子组件<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;slot&gt;&lt;/slot&gt;</span>
<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/template&gt;</span>
</code></pre></div></div>

<p>如上，渲染时子组件的<code class="language-plaintext highlighter-rouge">slot</code>标签会被父组件传入的<code class="language-plaintext highlighter-rouge">div.tmpl</code>替换。</p>

<h4 id="具名插槽">具名插槽</h4>

<p>匿名插槽没有name属性，所以叫匿名插槽。那么，插槽加了name属性，就变成了具名插槽。具名插槽可以在一个组件中出现N次，出现在不同的位置，只需要使用不同的name属性区分即可。</p>

<p>如：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;template&gt;</span>
<span class="c">&lt;!-- 父组件 parent.vue --&gt;</span>
<span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"parent"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;h1&gt;</span>父容器<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;child&gt;</span>
        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"tmpl"</span> <span class="na">slot=</span><span class="s">"up"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;span&gt;</span>菜单up-1<span class="nt">&lt;/span&gt;</span>
        <span class="nt">&lt;/div&gt;</span>
        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"tmpl"</span> <span class="na">slot=</span><span class="s">"down"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;span&gt;</span>菜单down-1<span class="nt">&lt;/span&gt;</span>
        <span class="nt">&lt;/div&gt;</span>
        <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"tmpl"</span><span class="nt">&gt;</span>
            <span class="nt">&lt;span&gt;</span>菜单-&gt;1<span class="nt">&lt;/span&gt;</span>
        <span class="nt">&lt;/div&gt;</span>
    <span class="nt">&lt;/child&gt;</span>
<span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/template&gt;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;template&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"child"</span><span class="nt">&gt;</span>
        <span class="c">&lt;!-- 具名插槽 --&gt;</span>
        <span class="nt">&lt;slot</span> <span class="na">name=</span><span class="s">"up"</span><span class="nt">&gt;&lt;/slot&gt;</span>
        <span class="nt">&lt;h3&gt;</span>这里是子组件<span class="nt">&lt;/h3&gt;</span>
        <span class="c">&lt;!-- 具名插槽 --&gt;</span>
        <span class="nt">&lt;slot</span> <span class="na">name=</span><span class="s">"down"</span><span class="nt">&gt;&lt;/slot&gt;</span>
        <span class="c">&lt;!-- 匿名插槽 --&gt;</span>
        <span class="nt">&lt;slot&gt;&lt;/slot&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/template&gt;</span>
</code></pre></div></div>

<p>如上，slot 标签会根据父容器给 child 标签内传入的内容的 slot 属性值，替换对应的内容。</p>

<p>其实，默认插槽也有 name 属性值，为<code class="language-plaintext highlighter-rouge">default</code>，同样指定  slot 的 name 值为 default，一样可以显示父组件中传入的没有指定slot的内容。</p>

<h4 id="作用域插槽">作用域插槽</h4>

<p>作用域插槽可以是默认插槽，也可以是具名插槽，不一样的地方是，作用域插槽可以为 slot 标签绑定数据，让其父组件可以获取到子组件的数据。</p>

<p>如：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;template&gt;</span>
    <span class="c">&lt;!-- parent.vue --&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"parent"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;h1&gt;</span>这是父组件<span class="nt">&lt;/h1&gt;</span>
        <span class="nt">&lt;current-user&gt;</span>
            <span class="nt">&lt;template</span> <span class="na">slot=</span><span class="s">"default"</span> <span class="na">slot-scope=</span><span class="s">"slotProps"</span><span class="nt">&gt;</span>
                
            <span class="nt">&lt;/template&gt;</span>
        <span class="nt">&lt;/current-user&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/template&gt;</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;template&gt;</span>
    <span class="c">&lt;!-- child.vue --&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"child"</span><span class="nt">&gt;</span>
        <span class="nt">&lt;h1&gt;</span>这是子组件<span class="nt">&lt;/h1&gt;</span>
        <span class="nt">&lt;slot</span> <span class="na">:user=</span><span class="s">"user"</span><span class="nt">&gt;&lt;/slot&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
<span class="nt">&lt;/template&gt;</span>
<span class="nt">&lt;script&gt;</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
    <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="na">user</span><span class="p">:</span> <span class="p">{</span>
                <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">小赵</span><span class="dl">'</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>如上例子，子组件 child 在渲染默认插槽 slot 的时候，将数据 user 传递给了 slot 标签，在渲染过程中，父组件可以通过<code class="language-plaintext highlighter-rouge">slot-scope</code>属性获取到 user 数据并渲染视图。</p>

<p>slot 实现原理：当子组件<code class="language-plaintext highlighter-rouge">vm</code>实例化时，获取到父组件传入的 slot 标签的内容，存放在<code class="language-plaintext highlighter-rouge">vm.$slot</code>中，默认插槽为<code class="language-plaintext highlighter-rouge">vm.$slot.default</code>，具名插槽为<code class="language-plaintext highlighter-rouge">vm.$slot.xxx</code>，xxx 为 插槽名，当组件执行渲染函数时候，遇到<code class="language-plaintext highlighter-rouge">&lt;slot&gt;</code>标签，使用<code class="language-plaintext highlighter-rouge">$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可曾该插槽为作用域插槽。</p>

<p>至此，父子组件的关系如下图：</p>

<p><img src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/images/posts/interview/1-2.png" alt="img" /></p>

<h3 id="模板渲染">模板渲染</h3>

<p>Vue.js 的核心是声明式渲染，与命令式渲染不同，声明式渲染只需要告诉程序，我们想要的什么效果，其他的事情让程序自己去做。而命令式渲染，需要命令程序一步一步根据命令执行渲染。如下例子区分：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">];</span>

<span class="c1">// 命令式渲染，关心每一步、关心流程。用命令去实现</span>
<span class="kd">var</span> <span class="nx">newArr</span> <span class="o">=</span> <span class="p">[];</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">newArr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">arr</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 声明式渲染，不用关心中间流程，只需要关心结果和实现的条件</span>
<span class="kd">var</span> <span class="nx">newArr1</span> <span class="o">=</span> <span class="nx">arr</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="kd">function</span> <span class="p">(</span><span class="nx">item</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">item</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Vue.js 实现了if、for、事件、数据绑定等指令，允许采用简洁的模板语法来声明式地将数据渲染出视图。</p>

<h4 id="模板编译">模板编译</h4>

<p>为什么要进行模板编译？实际上，我们组件中的 template 语法是无法被浏览器解析的，因为它不是正确的 HTML 语法，而模板编译，就是将组件的 template 编译成可执行的 JavaScript 代码，即将 template 转化为真正的渲染函数。</p>

<p>模板编译分三个阶段，<code class="language-plaintext highlighter-rouge">parse</code>、<code class="language-plaintext highlighter-rouge">optimize</code>、<code class="language-plaintext highlighter-rouge">generate</code>，最终生成<code class="language-plaintext highlighter-rouge">render</code>函数。</p>

<p><img src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/images/posts/interview/1-3.png" alt="img" /></p>

<p><code class="language-plaintext highlighter-rouge">parse</code>阶段：使用正在表达式将<code class="language-plaintext highlighter-rouge">template</code>进行字符串解析，得到指令、class、style等数据，生成抽象语法树 AST。</p>

<p><code class="language-plaintext highlighter-rouge">optimize</code>阶段：寻找 AST 中的静态节点进行标记，为后面 VNode 的 patch 过程中对比做优化。被标记为 static 的节点在后面的 diff 算法中会被直接忽略，不做详细的比较。</p>

<p><code class="language-plaintext highlighter-rouge">generate</code>阶段：根据 AST 结构拼接生成 render 函数的字符串。</p>

<h4 id="预编译">预编译</h4>

<p>对于 Vue 组件来说，模板编译只会在组件实例化的时候编译一次，生成渲染函数之后在也不会进行编译。因此，编译对组件的 runtime 是一种性能损耗。而模板编译的目的仅仅是将<code class="language-plaintext highlighter-rouge">template</code>转化为<code class="language-plaintext highlighter-rouge">render function</code>，而这个过程，正好可以在项目构建的过程中完成。</p>

<p>比如<code class="language-plaintext highlighter-rouge">webpack</code>的<code class="language-plaintext highlighter-rouge">vue-loader</code>依赖了<a href="https://www.npmjs.com/package/vue-template-compiler"><code class="language-plaintext highlighter-rouge">vue-template-compiler</code></a>模块，在 webpack 构建过程中，将<code class="language-plaintext highlighter-rouge">template</code>预编译成 render 函数，在 runtime 可直接跳过模板编译过程。</p>

<p>回过头看，runtime 需要是仅仅是 render 函数，而我们有了预编译之后，我们只需要保证构建过程中生成 render 函数就可以。与 React 类似，在添加<code class="language-plaintext highlighter-rouge">JSX</code>的语法糖编译器<a href="https://www.npmjs.com/package/babel-plugin-transform-vue-jsx"><code class="language-plaintext highlighter-rouge">babel-plugin-transform-vue-jsx</code></a>之后，我们可以在 Vue 组件中使用<code class="language-plaintext highlighter-rouge">JSX</code>语法直接书写 render 函数。</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script&gt;</span>
<span class="k">export</span> <span class="k">default</span> <span class="p">{</span>
    <span class="nx">data</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="na">msg</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Hello JSX.</span><span class="dl">'</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
        <span class="kd">const</span> <span class="nx">msg</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">msg</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
            <span class="p">{</span><span class="nx">msg</span><span class="p">}</span>
        <span class="o">&lt;</span><span class="sr">/div&gt;</span><span class="err">;
</span>    <span class="p">}</span>
<span class="p">}</span>
<span class="nt">&lt;/script&gt;</span>
</code></pre></div></div>

<p>如上面组件，使用 JSX 之后，可以在 JS 代码中直接使用 html 标签，而且声明了 render 函数以后，我们不再需要声明 template。当然，假如我们同时声明了 template 标签和 render 函数，构建过程中，template 编译的结果将覆盖原有的 render 函数，即 template 的优先级高于直接书写的 render 函数。</p>

<p>相对于 template 而言，JSX 具有更高的灵活性，面对与一些复杂的组件来说，JSX 有着天然的优势，而 template 虽然显得有些呆滞，但是代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p>

<p>需要注意的是，最后生成的 render 函数是被包裹在<code class="language-plaintext highlighter-rouge">with</code>语法中运行的。</p>

<h3 id="小结">小结</h3>

<p>Vue 组件通过 prop 进行数据传递，并实现了数据总线系统<code class="language-plaintext highlighter-rouge">EventBus</code>，组件集成了<code class="language-plaintext highlighter-rouge">EventBus</code>进行事件注册监听、事件触发，使用<code class="language-plaintext highlighter-rouge">slot</code>进行内容分发。</p>

<p>除此以外，实现了一套声明式模板系统，在<code class="language-plaintext highlighter-rouge">runtime</code>或者预编译是对模板进行编译，生成渲染函数，供组件渲染视图使用。</p>

<h2 id="响应式系统">响应式系统</h2>

<p>Vue.js 是一款 MVVM 的JS框架，当对数据模型<code class="language-plaintext highlighter-rouge">data</code>进行修改时，视图会自动得到更新，即框架帮我们完成了更新DOM的操作，而不需要我们手动的操作DOM。可以这么理解，当我们对数据进行赋值的时候，Vue 告诉了所有依赖该数据模型的组件，你依赖的数据有更新，你需要进行重渲染了，这个时候，组件就会重渲染，完成了视图的更新。</p>

<h3 id="数据模型--计算属性--监听器">数据模型 &amp;&amp; 计算属性 &amp;&amp; 监听器</h3>

<p>在组件中，可以为每个组件定义数据模型<code class="language-plaintext highlighter-rouge">data</code>、计算属性<code class="language-plaintext highlighter-rouge">computed</code>、监听器<code class="language-plaintext highlighter-rouge">watch</code>。</p>

<p>数据模型：Vue 实例在创建过程中，对数据模型<code class="language-plaintext highlighter-rouge">data</code>的每一个属性加入到响应式系统中，当数据被更改时，视图将得到响应，同步更新。<code class="language-plaintext highlighter-rouge">data</code>必须采用函数的方式 return，不使用 return 包裹的数据会在项目的全局可见，会造成变量污染；使用return包裹后数据中变量只在当前组件中生效，不会影响其他组件。</p>

<p>计算属性：<code class="language-plaintext highlighter-rouge">computed</code>基于组件响应式依赖进行计算得到结果并缓存起来。只在相关响应式依赖发生改变时它们才会重新求值，也就是说，只有它依赖的响应式数据（data、prop、computed本身）发生变化了才会重新计算。那什么时候应该使用计算属性呢？模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。对于任何复杂逻辑，你都应当使用计算属性。</p>

<p>监听器：监听器<code class="language-plaintext highlighter-rouge">watch</code>作用如其名，它可以监听响应式数据的变化，响应式数据包括 data、prop、computed，当响应式数据发生变化时，可以做出相应的处理。当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。</p>

<h3 id="响应式原理">响应式原理</h3>

<p>在 Vue 中，数据模型下的所有属性，会被 Vue 使用<code class="language-plaintext highlighter-rouge">Object.defineProperty</code>（Vue3.0 使用 Proxy）进行数据劫持代理。响应式的核心机制是观察者模式，数据是被观察的一方，一旦发生变化，通知所有观察者，这样观察者可以做出响应，比如当观察者为视图时，视图可以做出视图的更新。</p>

<p>Vue.js 的响应式系统以来三个重要的概念，<code class="language-plaintext highlighter-rouge">Observer</code>、<code class="language-plaintext highlighter-rouge">Dep</code>、<code class="language-plaintext highlighter-rouge">Watcher</code>。</p>

<h4 id="发布者-observer">发布者-Observer</h4>

<p>Observe 扮演的角色是发布者，他的主要作用是在组件<code class="language-plaintext highlighter-rouge">vm</code>初始化的时，调用<code class="language-plaintext highlighter-rouge">defineReactive</code>函数，使用<code class="language-plaintext highlighter-rouge">Object.defineProperty</code>方法对对象的每一个子属性进行数据劫持/监听，即为每个属性添加<code class="language-plaintext highlighter-rouge">getter</code>和<code class="language-plaintext highlighter-rouge">setter</code>，将对应的属性值变成响应式。</p>

<p>在组件初始化时，调用<code class="language-plaintext highlighter-rouge">initState</code>函数，内部执行<code class="language-plaintext highlighter-rouge">initState</code>、<code class="language-plaintext highlighter-rouge">initProps</code>、<code class="language-plaintext highlighter-rouge">initComputed</code>方法，分别对<code class="language-plaintext highlighter-rouge">data</code>、<code class="language-plaintext highlighter-rouge">prop</code>、<code class="language-plaintext highlighter-rouge">computed</code>进行初始化，让其变成响应式。</p>

<p>初始化<code class="language-plaintext highlighter-rouge">props</code>时，对所有<code class="language-plaintext highlighter-rouge">props</code>进行遍历，调用<code class="language-plaintext highlighter-rouge">defineReactive</code>函数，将每个 prop 属性值变成响应式，然后将其挂载到<code class="language-plaintext highlighter-rouge">_props</code>中，然后通过代理，把<code class="language-plaintext highlighter-rouge">vm.xxx</code>代理到<code class="language-plaintext highlighter-rouge">vm._props.xxx</code>中。</p>

<p>同理，初始化<code class="language-plaintext highlighter-rouge">data</code>时，与<code class="language-plaintext highlighter-rouge">prop</code>相同，对所有<code class="language-plaintext highlighter-rouge">data</code>进行遍历，调用<code class="language-plaintext highlighter-rouge">defineReactive</code>函数，将每个 data 属性值变成响应式，然后将其挂载到<code class="language-plaintext highlighter-rouge">_data</code>中，然后通过代理，把<code class="language-plaintext highlighter-rouge">vm.xxx</code>代理到<code class="language-plaintext highlighter-rouge">vm._data.xxx</code>中。</p>

<p>初始化<code class="language-plaintext highlighter-rouge">computed</code>，首先创建一个观察者对象<code class="language-plaintext highlighter-rouge">computed-watcher</code>，然后遍历<code class="language-plaintext highlighter-rouge">computed</code>的每一个属性，对每一个属性值调用<code class="language-plaintext highlighter-rouge">defineComputed</code>方法，使用<code class="language-plaintext highlighter-rouge">Object.defineProperty</code>将其变成响应式的同时，将其代理到组件实例上，即可通过<code class="language-plaintext highlighter-rouge">vm.xxx</code>访问到<code class="language-plaintext highlighter-rouge">xxx</code>计算属性。</p>

<h4 id="调度中心订阅器-dep">调度中心/订阅器-Dep</h4>

<p>Dep 扮演的角色是调度中心/订阅器，在调用<code class="language-plaintext highlighter-rouge">defineReactive</code>将属性值变成响应式的过程中，也为每个属性值实例化了一个<code class="language-plaintext highlighter-rouge">Dep</code>，主要作用是对观察者（Watcher）进行管理，收集观察者和通知观察者目标更新，即当属性值数据发生改变时，会遍历观察者列表（dep.subs），通知所有的 watcher，让订阅者执行自己的update逻辑。</p>

<p>其<code class="language-plaintext highlighter-rouge">dep</code>的任务是，在属性的<code class="language-plaintext highlighter-rouge">getter</code>方法中，调用<code class="language-plaintext highlighter-rouge">dep.depend()</code>方法，将观察者（即 Watcher，可能是组件的render function，可能是 computed，也可能是属性监听 watch）保存在内部，完成其依赖收集。在属性的<code class="language-plaintext highlighter-rouge">setter</code>方法中，调用<code class="language-plaintext highlighter-rouge">dep.notify()</code>方法，通知所有观察者执行更新，完成派发更新。</p>

<h4 id="观察者-watcher">观察者-Watcher</h4>

<p>Watcher 扮演的角色是订阅者/观察者，他的主要作用是为观察属性提供回调函数以及收集依赖，当被观察的值发生变化时，会接收到来自调度中心<code class="language-plaintext highlighter-rouge">Dep</code>的通知，从而触发回调函数。</p>

<p>而<code class="language-plaintext highlighter-rouge">Watcher</code>又分为三类，<code class="language-plaintext highlighter-rouge">normal-watcher</code>、 <code class="language-plaintext highlighter-rouge">computed-watcher</code>、 <code class="language-plaintext highlighter-rouge">render-watcher</code>。</p>

<ul>
  <li>
    <p>normal-watcher：在组件钩子函数<code class="language-plaintext highlighter-rouge">watch</code>中定义，即监听的属性改变了，都会触发定义好的回调函数。</p>
  </li>
  <li>
    <p>computed-watcher：在组件钩子函数<code class="language-plaintext highlighter-rouge">computed</code>中定义的，每一个<code class="language-plaintext highlighter-rouge">computed</code>属性，最后都会生成一个对应的<code class="language-plaintext highlighter-rouge">Watcher</code>对象，但是这类<code class="language-plaintext highlighter-rouge">Watcher</code>有个特点：当计算属性依赖于其他数据时，属性并不会立即重新计算，只有之后其他地方需要读取属性的时候，它才会真正计算，即具备<code class="language-plaintext highlighter-rouge">lazy</code>（懒计算）特性。</p>
  </li>
  <li>
    <p>render-watcher：每一个组件都会有一个<code class="language-plaintext highlighter-rouge">render-watcher</code>, 当<code class="language-plaintext highlighter-rouge">data/computed</code>中的属性改变的时候，会调用该<code class="language-plaintext highlighter-rouge">Watcher</code>来更新组件的视图。</p>
  </li>
</ul>

<p>这三种<code class="language-plaintext highlighter-rouge">Watcher</code>也有固定的执行顺序，分别是：computed-render -&gt; normal-watcher -&gt; render-watcher。这样就能尽可能的保证，在更新组件视图的时候，computed 属性已经是最新值了，如果 render-watcher 排在 computed-render 前面，就会导致页面更新的时候 computed 值为旧数据。</p>

<h3 id="小结-1">小结</h3>

<p><img src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/images/posts/interview/2-1.png" alt="响应式系统" /></p>

<p>Observer 负责将数据进行拦截，Watcher 负责订阅，观察数据变化， Dep 负责接收订阅并通知 Observer 和接收发布并通知所有 Watcher。</p>

<h2 id="virtual-dom">Virtual DOM</h2>

<p>在 Vue 中，<code class="language-plaintext highlighter-rouge">template</code>被编译成浏览器可执行的<code class="language-plaintext highlighter-rouge">render function</code>，然后配合响应式系统，将<code class="language-plaintext highlighter-rouge">render function</code>挂载在<code class="language-plaintext highlighter-rouge">render-watcher</code>中，当有数据更改的时候，调度中心<code class="language-plaintext highlighter-rouge">Dep</code>通知该<code class="language-plaintext highlighter-rouge">render-watcher</code>执行<code class="language-plaintext highlighter-rouge">render function</code>，完成视图的渲染与更新。</p>

<p><img src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/images/posts/interview/3-1.png" alt="DOM更新" /></p>

<p>整个流程看似通顺，但是当执行<code class="language-plaintext highlighter-rouge">render function</code>时，如果每次都全量删除并重建 DOM，这对执行性能来说，无疑是一种巨大的损耗，因为我们知道，浏览器的DOM很“昂贵”的，当我们频繁的更新 DOM，会产生一定的性能问题。</p>

<p>为了解决这个问题，Vue 使用 JS 对象将浏览器的 DOM 进行的抽象，这个抽象被称为 Virtual DOM。Virtual DOM 的每个节点被定义为<code class="language-plaintext highlighter-rouge">VNode</code>，当每次执行<code class="language-plaintext highlighter-rouge">render function</code>时，Vue 对更新前后的<code class="language-plaintext highlighter-rouge">VNode</code>进行<code class="language-plaintext highlighter-rouge">Diff</code>对比，找出尽可能少的我们需要更新的真实 DOM 节点，然后只更新需要更新的节点，从而解决频繁更新 DOM 产生的性能问题。</p>

<h3 id="vnode">VNode</h3>

<p>VNode，全称<code class="language-plaintext highlighter-rouge">virtual node</code>，即虚拟节点，对真实 DOM 节点的虚拟描述，在 Vue 的每一个组件实例中，会挂载一个<code class="language-plaintext highlighter-rouge">$createElement</code>函数，所有的<code class="language-plaintext highlighter-rouge">VNode</code>都是由这个函数创建的。</p>

<p>比如创建一个 div：</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 声明 render function</span>
<span class="nx">render</span><span class="p">:</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">createElement</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 也可以使用 this.$createElement 创建 VNode</span>
    <span class="k">return</span> <span class="nx">createElement</span><span class="p">(</span><span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">hellow world</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 以上 render 方法返回html片段 &lt;div&gt;hellow world&lt;/div&gt;</span>
</code></pre></div></div>

<p>render 函数执行后，会根据<code class="language-plaintext highlighter-rouge">VNode Tree</code>将 VNode 映射生成真实 DOM，从而完成视图的渲染。</p>

<h3 id="diff">Diff</h3>

<p>Diff 将新老 VNode 节点进行比对，然后将根据两者的比较结果进行最小单位地修改视图，而不是将整个视图根据新的 VNode 重绘，进而达到提升性能的目的。</p>

<h4 id="patch">patch</h4>

<p>Vue.js 内部的 diff 被称为<code class="language-plaintext highlighter-rouge">patch</code>。其 diff 算法的是通过同层的树节点进行比较，而非对树进行逐层搜索遍历的方式，所以时间复杂度只有O(n)，是一种相当高效的算法。</p>

<p><img src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/images/posts/interview/3-2.png" alt="DIFF" /></p>

<p>首先定义新老节点是否相同判定函数<code class="language-plaintext highlighter-rouge">sameVnode</code>：满足键值<code class="language-plaintext highlighter-rouge">key</code>和标签名<code class="language-plaintext highlighter-rouge">tag</code>必须一致等条件，返回<code class="language-plaintext highlighter-rouge">true</code>，否则<code class="language-plaintext highlighter-rouge">false</code>。</p>

<p>在进行<code class="language-plaintext highlighter-rouge">patch</code>之前，新老 VNode 是否满足条件<code class="language-plaintext highlighter-rouge">sameVnode(oldVnode, newVnode)</code>，满足条件之后，进入流程<code class="language-plaintext highlighter-rouge">patchVnode</code>，否则被判定为不相同节点，此时会移除老节点，创建新节点。</p>

<h4 id="patchvnode">patchVnode</h4>

<p>patchVnode 的主要作用是判定如何对子节点进行更新，</p>

<ol>
  <li>
    <p>如果新旧VNode都是静态的，同时它们的key相同（代表同一节点），并且新的 VNode 是 clone 或者是标记了 once（标记v-once属性，只渲染一次），那么只需要替换 DOM 以及 VNode 即可。</p>
  </li>
  <li>
    <p>新老节点均有子节点，则对子节点进行 diff 操作，进行<code class="language-plaintext highlighter-rouge">updateChildren</code>，这个 updateChildren 也是 diff 的核心。</p>
  </li>
  <li>
    <p>如果老节点没有子节点而新节点存在子节点，先清空老节点 DOM 的文本内容，然后为当前 DOM 节点加入子节点。</p>
  </li>
  <li>
    <p>当新节点没有子节点而老节点有子节点的时候，则移除该 DOM 节点的所有子节点。</p>
  </li>
  <li>
    <p>当新老节点都无子节点的时候，只是文本的替换。</p>
  </li>
</ol>

<h4 id="updatechildren">updateChildren</h4>

<p>Diff 的核心，对比新老子节点数据，判定如何对子节点进行操作，在对比过程中，由于老的子节点存在对当前真实 DOM 的引用，新的子节点只是一个 VNode 数组，所以在进行遍历的过程中，若发现需要更新真实 DOM 的地方，则会直接在老的子节点上进行真实 DOM 的操作，等到遍历结束，新老子节点则已同步结束。</p>

<p><code class="language-plaintext highlighter-rouge">updateChildren</code>内部定义了4个变量，分别是<code class="language-plaintext highlighter-rouge">oldStartIdx</code>、<code class="language-plaintext highlighter-rouge">oldEndIdx</code>、<code class="language-plaintext highlighter-rouge">newStartIdx</code>、<code class="language-plaintext highlighter-rouge">newEndIdx</code>，分别表示正在 Diff 对比的新老子节点的左右边界点索引，在老子节点数组中，索引在<code class="language-plaintext highlighter-rouge">oldStartIdx</code>与<code class="language-plaintext highlighter-rouge">oldEndIdx</code>中间的节点，表示老子节点中为被遍历处理的节点，所以小于<code class="language-plaintext highlighter-rouge">oldStartIdx</code>或大于<code class="language-plaintext highlighter-rouge">oldEndIdx</code>的表示未被遍历处理的节点。同理，在新的子节点数组中，索引在<code class="language-plaintext highlighter-rouge">newStartIdx</code>与<code class="language-plaintext highlighter-rouge">newEndIdx</code>中间的节点，表示老子节点中为被遍历处理的节点，所以小于<code class="language-plaintext highlighter-rouge">newStartIdx</code>或大于<code class="language-plaintext highlighter-rouge">newEndIdx</code>的表示未被遍历处理的节点。</p>

<p>每一次遍历，<code class="language-plaintext highlighter-rouge">oldStartIdx</code>和<code class="language-plaintext highlighter-rouge">oldEndIdx</code>与<code class="language-plaintext highlighter-rouge">newStartIdx</code>和<code class="language-plaintext highlighter-rouge">newEndIdx</code>之间的距离会向中间靠拢。当 oldStartIdx &gt; oldEndIdx 或者 newStartIdx &gt; newEndIdx 时结束循环。</p>

<p><img src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/images/posts/interview/3-3.png" alt="img" /></p>

<p>在遍历中，取出4索引对应的 Vnode节点：</p>

<ul>
  <li>oldStartIdx：oldStartVnode</li>
  <li>oldEndIdx：oldEndVnode</li>
  <li>newStartIdx：newStartVnode</li>
  <li>newEndIdx：newEndVnode</li>
</ul>

<p>diff 过程中，如果存在<code class="language-plaintext highlighter-rouge">key</code>，并且满足<code class="language-plaintext highlighter-rouge">sameVnode</code>，会将该 DOM 节点进行复用，否则则会创建一个新的 DOM 节点。</p>

<p>首先，<code class="language-plaintext highlighter-rouge">oldStartVnode</code>、<code class="language-plaintext highlighter-rouge">oldEndVnode</code>与<code class="language-plaintext highlighter-rouge">newStartVnode</code>、<code class="language-plaintext highlighter-rouge">newEndVnode</code>两两比较，一共有 2*2=4 种比较方法。</p>

<p>情况一：当<code class="language-plaintext highlighter-rouge">oldStartVnode</code>与<code class="language-plaintext highlighter-rouge">newStartVnode</code>满足 sameVnode，则<code class="language-plaintext highlighter-rouge">oldStartVnode</code>与<code class="language-plaintext highlighter-rouge">newStartVnode</code>进行 patchVnode，并且<code class="language-plaintext highlighter-rouge">oldStartIdx</code>与<code class="language-plaintext highlighter-rouge">newStartIdx</code>右移动。</p>

<p><img src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/images/posts/interview/3-4.png" alt="img" /></p>

<p>情况二：与情况一类似，当<code class="language-plaintext highlighter-rouge">oldEndVnode</code>与<code class="language-plaintext highlighter-rouge">newEndVnode</code>满足 sameVnode，则<code class="language-plaintext highlighter-rouge">oldEndVnode</code>与<code class="language-plaintext highlighter-rouge">newEndVnode</code>进行 patchVnode，并且<code class="language-plaintext highlighter-rouge">oldEndIdx</code>与<code class="language-plaintext highlighter-rouge">newEndIdx</code>左移动。</p>

<p><img src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/images/posts/interview/3-5.png" alt="img" /></p>

<p>情况三：当<code class="language-plaintext highlighter-rouge">oldStartVnode</code>与<code class="language-plaintext highlighter-rouge">newEndVnode</code>满足 sameVnode，则说明<code class="language-plaintext highlighter-rouge">oldStartVnode</code>已经跑到了<code class="language-plaintext highlighter-rouge">oldEndVnode</code>后面去了，此时<code class="language-plaintext highlighter-rouge">oldStartVnode</code>与<code class="language-plaintext highlighter-rouge">newEndVnode</code>进行 patchVnode 的同时，还需要将<code class="language-plaintext highlighter-rouge">oldStartVnode</code>的真实 DOM 节点移动到<code class="language-plaintext highlighter-rouge">oldEndVnode</code>的后面，并且<code class="language-plaintext highlighter-rouge">oldStartIdx</code>右移，<code class="language-plaintext highlighter-rouge">newEndIdx</code>左移。</p>

<p><img src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/images/posts/interview/3-6.png" alt="img" /></p>

<p>情况四：与情况三类似，当<code class="language-plaintext highlighter-rouge">oldEndVnode</code>与<code class="language-plaintext highlighter-rouge">newStartVnode</code>满足 sameVnode，则说明<code class="language-plaintext highlighter-rouge">oldEndVnode</code>已经跑到了<code class="language-plaintext highlighter-rouge">oldStartVnode</code>前面去了，此时<code class="language-plaintext highlighter-rouge">oldEndVnode</code>与<code class="language-plaintext highlighter-rouge">newStartVnode</code>进行 patchVnode 的同时，还需要将<code class="language-plaintext highlighter-rouge">oldEndVnode</code>的真实 DOM 节点移动到<code class="language-plaintext highlighter-rouge">oldStartVnode</code>的前面，并且<code class="language-plaintext highlighter-rouge">oldStartIdx</code>右移，<code class="language-plaintext highlighter-rouge">newEndIdx</code>左移。</p>

<p><img src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/images/posts/interview/3-7.png" alt="img" /></p>

<p>当这四种情况都不满足，则在<code class="language-plaintext highlighter-rouge">oldStartIdx</code>与<code class="language-plaintext highlighter-rouge">oldEndIdx</code>之间查找与<code class="language-plaintext highlighter-rouge">newStartVnode</code>满足<code class="language-plaintext highlighter-rouge">sameVnode</code>的节点，若存在，则将匹配的节点真实 DOM 移动到<code class="language-plaintext highlighter-rouge">oldStartVnode</code>的前面。</p>

<p><img src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/images/posts/interview/3-8.png" alt="img" /></p>

<p>若不存在，说明<code class="language-plaintext highlighter-rouge">newStartVnode</code>为新节点，创建新节点放在<code class="language-plaintext highlighter-rouge">oldStartVnode</code>前面即可。</p>

<p><img src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/images/posts/interview/3-9.png" alt="img" /></p>

<p>当 oldStartIdx &gt; oldEndIdx 或者 newStartIdx &gt; newEndIdx，循环结束，这个时候我们需要处理那些未被遍历到的 VNode。</p>

<p>当 oldStartIdx &gt; oldEndIdx 时，说明老的节点已经遍历完，而新的节点没遍历完，这个时候需要将新的节点创建之后放在<code class="language-plaintext highlighter-rouge">oldEndVnode</code>后面。</p>

<p><img src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/images/posts/interview/3-10.png" alt="img" /></p>

<p>当 newStartIdx &gt; newEndIdx 时，说明新的节点已经遍历完，而老的节点没遍历完，这个时候要将没遍历的老的节点全都删除。</p>

<p><img src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/images/posts/interview/3-11.png" alt="img" /></p>

<p>此时已经完成了子节点的匹配。下面是一个例子 patch 过程图：</p>

<p><img src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/images/posts/interview/patchChildren.gif" alt="patchChildren" /></p>

<h2 id="总结">总结</h2>

<p>借用官方的一幅图：</p>

<p><img src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/images/posts/interview/final.png" alt="final" /></p>

<p>Vue.js 实现了一套声明式渲染引擎，并在<code class="language-plaintext highlighter-rouge">runtime</code>或者预编译时将声明式的模板编译成渲染函数，挂载在观察者 Watcher 中，在渲染函数中（touch），响应式系统使用响应式数据的<code class="language-plaintext highlighter-rouge">getter</code>方法对观察者进行依赖收集（Collect as Dependency），使用响应式数据的<code class="language-plaintext highlighter-rouge">setter</code>方法通知（notify）所有观察者进行更新，此时观察者 Watcher 会触发组件的渲染函数（Trigger re-render），组件执行的 render 函数，生成一个新的 Virtual DOM Tree，此时 Vue 会对新老 Virtual DOM Tree 进行 Diff，查找出需要操作的真实 DOM 并对其进行更新。</p>

<h2 id="参考">参考</h2>

<ul>
  <li>
    <p><a href="https://mp.weixin.qq.com/s?__biz=MzIyMDEwNzIwNQ==&amp;mid=2649619127&amp;idx=1&amp;sn=e75d7ae41b679b9e2f558bee8f1ea82d&amp;scene=4#wechat_redirect">聊聊 VueJs 组件化编程</a></p>
  </li>
  <li>
    <p><a href="https://juejin.im/post/5a69ece0f265da3e5a5777ed?utm_source=gold_browser_extension">深入理解vue中的slot与slot-scope</a></p>
  </li>
  <li>
    <p><a href="https://blog.csdn.net/hf872914334/article/details/89098295">vue响应式系统–observe、watcher、dep</a></p>
  </li>
  <li>
    <p><a href="https://ustbhuangyi.github.io/vue-analysis/v2/prepare/">Vue.js技术揭秘</a></p>
  </li>
  <li>
    <p><a href="https://juejin.im/post/59bfbd736fb9a00a52065ec7">VirtualDOM与diff(Vue实现)</a></p>
  </li>
</ul>

    <div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7">
  <h3>文档信息</h3>
  <ul>
    
    <li>本文作者：<a href="http://localhost:4000" target="_blank">Liang Qi</a></li>
    <li>本文链接：<a href="http://localhost:4000/2020/07/04/Understanding-of-Vue/" target="_blank">http://localhost:4000/2020/07/04/Understanding-of-Vue/</a></li>
    <li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li>    
    
  </ul>
</div>

    </article>
    <div class="comment">
      

  

  
        <div id="gitalk-container"></div>
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
        <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
        <script>
        var gitalk = new Gitalk({
            id: '/2020/07/04/Understanding-of-Vue/',
            clientID: '0f1df03507262b92fd0e',
            clientSecret: '08cb3c71e4bd1aad2087b35962258d7eb284c543',
            repo: 'blog-comments',
            owner: 'ttcoder404',
            admin: ['ttcoder404'],
            labels: ['gitment'],
            perPage: 50,
        });
        gitalk.render('gitalk-container');
        </script>
  


    </div>
  </div>
  <div class="column one-fourth">
    
<h3>Search</h3>
<div id="site_search">
    <input style="width:96%" type="text" id="search_box" placeholder="Search">
</div>

<ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul>

<script src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/assets/js/simple-jekyll-search.min.js"></script>

<script type="text/javascript">
SimpleJekyllSearch({
    searchInput: document.getElementById('search_box'),
    resultsContainer: document.getElementById('search_results'),
    json: 'http://localhost:4000/assets/search_data.json',
    searchResultTemplate: '<li><a href="{url}" title="{desc}">{title}</a></li>',
    noResultsText: 'No results found',
    limit: 10,
    fuzzy: false,
    exclude: ['Welcome']
})
</script>

    <div id="post-box">
  <h3 class="post-directory-title mobile-hidden">聊聊对Vue.js框架的理解</h3>
  <div id="post-directory-module" class="mobile-hidden">
    <section class="post-directory">
    <!-- Links that trigger the jumping -->
    <!-- Added by javascript below -->
    <dl></dl>
    </section>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/assets/js/jquery.toc.js"></script>

  </div>
</div>
</section>
<!-- /section.content -->
        </div>

    <footer class="container">

    <div class="site-footer" role="contentinfo">

        <div class="copyright pull-left mobile-block">
            © 2020
            <span title="Liang Qi">Liang Qi</span>
            <span>
                Power by <a href="https://github.com/DONGChuan/Yummy-Jekyll" target="_blank">Yummy Jekyll</a>
            </span>
            <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a>
        </div>
        <div class="pull-right">
            <a href="javascript:window.scrollTo(0,0)" >TOP</a>
        </div>
        
        <ul class="site-footer-links mobile-hidden">
            
            <li>
                <a href="http://localhost:4000/" title="Home" target="">Home</a>
            </li>
            
            <li>
                <a href="http://localhost:4000/open-source" title="Open-Source" target="">Open-Source</a>
            </li>
            
            <li>
                <a href="http://localhost:4000/talk" title="Talk" target="">Talk</a>
            </li>
            
            <li>
                <a href="http://localhost:4000/archives" title="Archive" target="">Archive</a>
            </li>
            
            <li>
                <a href="http://localhost:4000/about" title="About" target="">About</a>
            </li>
            
            <li><a href="http://localhost:4000/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li>
        </ul>

      <!-- 不蒜子访问统计 -->

<script async src="https://cdn.jsdelivr.net/gh/ttcoder404/ttcoder404.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="mobile-hidden" style="margin-top:8px">
  <span id="busuanzi_container_site_pv" style="display:none">
    本站访问量<span id="busuanzi_value_site_pv"></span>次
  </span>
  <span id="busuanzi_container_site_uv" style="display:none">
    / 本站访客数<span id="busuanzi_value_site_uv"></span>人
  </span>
  <span id="busuanzi_container_page_pv" style="display:none">
    / 本页访问量<span id="busuanzi_value_page_pv"></span>次
    
    / 统计始于2020-06-05
    
  </span>
</div>



    </div>

    <!-- Third-Party JS -->
    <script type="text/javascript" src="/bower_components/geopattern/js/geopattern.min.js"></script>

    <!-- My JS -->
    <script type="text/javascript" src="/assets/js/script.js"></script>

    

    

</footer>


    </body>

</html>
